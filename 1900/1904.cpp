// BOJ 1904 - 01타일
// 다이나믹 프로그래밍 문제 - 규칙이 존재하는데 규칙을 찾으면 쉽게 풀 수 있다.
// 예를 들면 4의 크기를 구하려고 할 때, 2의 크기의 타일과 3의 크기의 타일을 가지고 갯수를 구할 수 있다.
// 2의 크기인 00, 11를 보면
// 00 + 1 or 00 이지만 4의 크기이므로 0000 으로만 만들 수 있고
// 11 + 1 or 00 이지만 4의 크기이므로 1100 으로만 만들 수 있다.
// 또한 3의 크기인 001, 111, 100를 보면
// 001 + 1 or 00 이지만 4의 크기이므로 0011 으로만 만들 수 있고
// 111 + 1 or 00 이지만 4의 크기이므로 1111 으로만 만들 수 있다.
// 100 + 1 or 00 도 마찬가지로 4의 크기이므로 1001 으로만 만들 수 있다.
// 정리해보면 N 크기의 타일을 만들때는 N-1 크기의 타일로는 1 or 00 중에서 하나만 골라서 만들 수 있고,
// N-2 크기의 타일을 만들때도 각각 1 or 00 중에서 하나만 골라서 만들 수 있다.
// 하지만 우리는 만드는 방법이 중요하지 않고 만들 수 있는 갯수만 알면 되기 때문에
// dp[N] = dp[N-1] + dp[N-2] 과 같은 식이 성립하는 것이다.
#include <iostream>
using namespace std;
const int mod = 15746;
long long dp[1000001];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
    int n;
    cin >> n;
    
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = (dp[i-1] % mod) + (dp[i-2] % mod);
        dp[i] %= mod;
    }
    
    cout << dp[n] % mod << '\n';
    return 0;
}

