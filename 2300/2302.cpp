// BOJ 2302 - 극장 좌석
// 부분적인 규칙을 찾아냈으나, 전체적인 규칙이랑 구현을 하지 못해서 블로그 참고해서 해결했다.
//
// 피보나치 수열의 응용 문제라고 이해하면 될 것 같다. (DP 로 해결)
// i번째 위치에 앉게되면.. i-1 번째 그리고 i+1 번째 위치에 앉을 수 있다.
// 1. 피보나치의 점화식을 구해보자
// N = 1인 경우에는 좌석은 1개이기 때문에 1이다. (참고로 피보나치 특성상 0일때도 값은 1)
// N = 2인 경우에는 앉을 수 있는 경우의 수가 2개이다. (12, 21)
// N = 3인 경우에는 앉을 수 있는 경우의 수가 3개이다. (123, 213, 132)
// 위에서 점화식을 도출할 수 있는데
// i가 i번째 위치에 앉을때는 기존의 i-1의 경우의 수이다. (12, 21 -> 123, 213)
// i가 i-1번째 위치에 앉을때는 기존의 i-2의 경우의 수이다. (1 -> 132)
// (i가 i-1번째에 앉으면 자연스레 i-1은 i번째에 앉게 됨)
// 따라서 점화식은 다음과 같다.
// dp[i] = dp[i-1] + dp[i-2] (2 <= i <= n)
// 2. VIP 좌석이 존재할때랑 존재하지 않는 경우는 어떻게 처리할까?
// 1) VIP 좌석이 존재하지 않는다면?
//      0번째에서 n번째까지의 피보나치 수열의 값을 출력하면 된다.
// 2) VIP 좌석이 존재한다면..
//      결과 값 = (0번째에서 첫 번째 VIP위치까지의 피보나치 수열)
//       x (첫 번째 VIP위치에서 두 번째 VIP위치의 피보나치 수열) x ...
//       x (i 번째 VIP위치에서 i+1번째 VIP위치의 피보나치 수열)
//       x (n 번째에서 위치에서 i+1 VIP위치의 피보나치 수열)
// 다음과 같이 처리해주면 된다.
#include <iostream>
#include <vector>
using namespace std;
int dp[41];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
    int n;
    cin >> n;
    dp[0] = dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    
    int m;
    cin >> m;
    vector<int> vip(m+1, 0);
    for (int i = 1; i <= m; i++) {
        cin >> vip[i];
    }
    
    int ans = 1;
    for (int i = 1; i <= m; i++) {
        ans *= dp[vip[i] - vip[i-1] - 1];
    }
    ans *= dp[n - vip[m]];
    
    cout << ans << '\n';
    return 0;
}
