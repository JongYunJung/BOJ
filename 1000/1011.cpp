// BOJ 1011 Fly me to the Alpha Centauri
// 어려웠음.. 인터넷 참고
// [해결 방법]
// 거리(dist = y - x)
// 거리(dist)를 1 ~ 65536 (2^16) 늘려서 찾다보면 규칙성을 찾을 수 있음
// (!!! 중요 !!!) 처음 시작과 마지막 워프(이동)는 무조건 1
// ************************** n = 1 **************************
// dist = 1,  워프(이동) 1,           최소 워프 횟수 1 => 2 * n - 1
// -----------------------------------------------------------
// dist = 2,  워프(이동) 1 1,         최소 워프 횟수 2 => 2 * n
// ************************** n = 2 **************************
// dist = 3,  워프(이동) 1 1 1,       최소 워프 횟수 3 => 2 * n - 1
// dist = 4,  워프(이동) 1 2 1,       최소 워프 횟수 3 => 2 * n - 1
// -----------------------------------------------------------
// dist = 5,  워프(이동) 1 2 1 1,     최소 워프 횟수 4 => 2 * n
// dist = 6,  워프(이동) 1 2 2 1,     최소 워프 횟수 4 => 2 * n
// ************************** n = 3 **************************
// dist = 7,  워프(이동) 1 2 2 1 1,   최소 워프 횟수 5 => 2 * n - 1
// dist = 8,  워프(이동) 1 2 2 2 1,   최소 워프 횟수 5 => 2 * n - 1
// dist = 9,  워프(이동) 1 2 3 2 1,   최소 워프 횟수 5 => 2 * n - 1
// -----------------------------------------------------------
// dist = 10, 워프(이동) 1 2 3 2 1 1, 최소 워프 횟수 6 => 2 * n
// dist = 11, 워프(이동) 1 2 3 2 2 1, 최소 워프 횟수 6 => 2 * n
// dist = 12, 워프(이동) 1 2 3 3 2 1, 최소 워프 횟수 6 => 2 * n
//
// 특정 n^2(dist) 을 기준으로 n개의 2 * n - 1, n개의 2 * n 개의 최소 워프 횟수를 구할 수 있다.
// n = 1, dist(1^2) = 1,  최소 워프 횟수 1(2*n-1), 2(2*n)
// n = 2, dist(2^2) = 4,  최소 워프 횟수 3(2*n-1), 4(2*n)
// n = 3, dist(3^2) = 9,  최소 워프 횟수 5(2*n-1), 6(2*n)
// n = 4, dist(4^2) = 16, 최소 워프 횟수 7(2*n-1), 8(2*n)
//
#include <iostream>
#include <math.h>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
    int tc;
    cin >> tc;
    while (tc--) {
        int x, y;
        cin >> x >> y;
        long long dist = y - x;
        long long warpCount = 0;
        for(long long n = 1;; n++) {
            long long powNum = n * n;
            long long minNum = powNum - n + 1;
            long long maxNum = powNum + n;
            if (minNum <= dist && dist <= maxNum) {
                if (powNum >= dist) warpCount = 2 * n - 1;
                else warpCount = 2 * n;
                break;
            }
        }
        cout << warpCount << '\n';
    }
    
    return 0;
}

